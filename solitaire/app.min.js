const COLORS = {
    GOLD: '#E6D39E',
    BLACK: '#141414',
    RED: '#FF0000',
    DARK_BLACK: '#000000',
    WHITE: '#FFFFFF',
    GRADIENT_START: '#141414',
    GRADIENT_END: '#332B1A'
};
const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const SUIT_SYMBOLS = { hearts: '♥', diamonds: '♦', clubs: '♣', spades: '♠' };
let canvas, ctx;
let cardWidth = 80, cardHeight = 120;
let scale = 1;
let deck = [];
let tableau = Array(7).fill().map(() => []);
let foundations = Array(4).fill().map(() => []);
let stock = [];
let waste = [];
let selectedCards = null;
let dragOffset = {x: 0, y: 0};
let moves = [];
let score = 0;
let drawMode = 1;
let timed = false;
let startTime = 0;
let hintsEnabled = true;
let autoComplete = false;
let wins = 0, losses = 0, streak = 0;
let rank = 'Bronze Chip';
let reducedMotion = false;
let showTutorial = !localStorage.getItem('tutorialSeen');
let showSettings = false;

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

function init() {
    try {
        canvas = document.getElementById('gameCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('Failed to get 2D context');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        newGame();
        renderBoard();
    } catch (error) {
        console.error('Initialization error:', error);
        document.getElementById('aria-announcer').textContent = 'Error initializing game';
    }
}

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    scale = Math.min(canvas.width / 800, canvas.height / 600);
    ctx.scale(scale * dpr, scale * dpr);
    cardWidth = 80 * scale;
    cardHeight = 120 * scale;
    renderBoard();
}

function newGame() {
    deck = [];
    SUITS.forEach(suit => {
        RANKS.forEach(rank => {
            deck.push({suit, rank, faceUp: false, id: generateUUID()});
        });
    });
    shuffle(deck);
    tableau = Array(7).fill().map(() => []);
    foundations = Array(4).fill().map(() => []);
    stock = deck.slice();
    waste = [];
    for (let i = 0; i < 7; i++) {
        for (let j = 0; j <= i; j++) {
            tableau[i].push(stock.pop());
            if (j === i) tableau[i][j].faceUp = true;
        }
    }
    score = 0;
    moves = [];
    startTime = Date.now();
    renderBoard();
    document.getElementById('aria-announcer').textContent = 'New game started';
}

function renderBoard() {
    ctx.fillStyle = COLORS.BLACK;
    ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
    const offsetX = (canvas.width / scale - 800) / 2;
    const offsetY = (canvas.height / scale - 600) / 2;
    foundations.forEach((pile, i) => {
        drawCardSlot(20 + i * 100 + offsetX, 20 + offsetY, SUIT_SYMBOLS[SUITS[i]]);
    });
    drawCardSlot(20 + offsetX, 100 + offsetY, 'Stock');
    drawCardSlot(120 + offsetX, 100 + offsetY, 'Waste');
    tableau.forEach((pile, i) => {
        pile.forEach((card, j) => {
            drawCard(card, 20 + i * 100 + offsetX, 250 + j * 20 + offsetY);
        });
        if (!pile.length) drawCardSlot(20 + i * 100 + offsetX, 250 + offsetY);
    });
    waste.forEach((card, i) => {
        if (i === waste.length - 1) drawCard(card, 120 + offsetX, 100 + offsetY);
    });
    if (stock.length) drawCard(stock[stock.length - 1], 20 + offsetX, 100 + offsetY, true);
    drawButton(650 + offsetX, 20 + offsetY, 'Undo', moves.length > 0);
    drawButton(650 + offsetX, 70 + offsetY, 'Hint', hintsEnabled);
    drawButton(650 + offsetX, 120 + offsetY, 'New Game', true);
    drawButton(650 + offsetX, 170 + offsetY, 'Settings', true);
    if (showSettings) drawSettings(300 + offsetX, 200 + offsetY);
    if (showTutorial) drawTutorial(300 + offsetX, 200 + offsetY);
    if (selectedCards) {
        selectedCards.cards.forEach((card, i) => {
            drawCard(card, selectedCards.pos.x - dragOffset.x + i * 20, selectedCards.pos.y - dragOffset.y + i * 20);
        });
    }
    drawDebug(offsetX, offsetY);
}

function drawCard(card, x, y, isBack = false) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, cardWidth / scale, cardHeight / scale);
    ctx.fillStyle = isBack ? COLORS.GRADIENT_START : COLORS.WHITE;
    ctx.fill();
    ctx.strokeStyle = COLORS.BLACK;
    ctx.lineWidth = 2;
    ctx.stroke();
    if (!isBack && card.faceUp) {
        ctx.fillStyle = card.suit === 'hearts' || card.suit === 'diamonds' ? COLORS.RED : COLORS.BLACK;
        ctx.font = `${20 * scale}px Arial`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(`${card.rank}${SUIT_SYMBOLS[card.suit]}`, x + 5, y + 5);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.fillText(`${card.rank}${SUIT_SYMBOLS[card.suit]}`, x + cardWidth / scale - 5, y + cardHeight / scale - 5);
    }
    ctx.restore();
}

function drawCardSlot(x, y, label = '') {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, cardWidth / scale, cardHeight / scale);
    ctx.strokeStyle = COLORS.GOLD;
    ctx.lineWidth = 2;
    ctx.stroke();
    if (label) {
        ctx.fillStyle = COLORS.GOLD;
        ctx.font = `${16 * scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + cardWidth / scale / 2, y + cardHeight / scale / 2);
    }
    ctx.restore();
}

function drawButton(x, y, label, enabled) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, 100, 40);
    ctx.fillStyle = enabled ? COLORS.GOLD : COLORS.DARK_BLACK;
    ctx.fill();
    ctx.strokeStyle = COLORS.BLACK;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = COLORS.BLACK;
    ctx.font = `${16 * scale}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x + 50, y + 20);
    ctx.restore();
}

function drawSettings(x, y) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, 200, 200);
    ctx.fillStyle = COLORS.BLACK;
    ctx.fill();
    ctx.strokeStyle = COLORS.GOLD;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = COLORS.GOLD;
    ctx.font = `${16 * scale}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Settings', x + 100, y + 20);
    ctx.fillText(`Draw: ${drawMode === 1 ? 'One' : 'Three'}`, x + 100, y + 60);
    ctx.fillText(`Timed: ${timed ? 'On' : 'Off'}`, x + 100, y + 100);
    ctx.fillText(`Hints: ${hintsEnabled ? 'On' : 'Off'}`, x + 100, y + 140);
    ctx.fillText('Close', x + 100, y + 180);
    ctx.restore();
}

function drawTutorial(x, y) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, 200, 200);
    ctx.fillStyle = COLORS.BLACK;
    ctx.fill();
    ctx.strokeStyle = COLORS.GOLD;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = COLORS.GOLD;
    ctx.font = `${16 * scale}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Tutorial', x + 100, y + 20);
    ctx.fillText('Click stock to draw', x + 100, y + 60);
    ctx.fillText('Drag cards to move', x + 100, y + 100);
    ctx.fillText('Build foundations', x + 100, y + 140);
    ctx.fillText('Close', x + 100, y + 180);
    ctx.restore();
}

function drawDebug(offsetX, offsetY) {
    const debug = document.getElementById('debug');
    if (debug) {
        debug.textContent = `Score: ${score} | Moves: ${moves.length} | Time: ${timed ? Math.floor((Date.now() - startTime) / 1000) : 0} | Rank: ${rank} | Streak: ${streak}`;
    }
}

function isInBounds(pos, x, y, w, h) {
    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
}

function handleMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const pos = {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
    };
    handleClick(pos);
}

function handleMouseMove(e) {
    if (!selectedCards) return;
    const rect = canvas.getBoundingClientRect();
    selectedCards.pos = {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
    };
    renderBoard();
}

function handleMouseUp(e) {
    if (!selectedCards) return;
    const rect = canvas.getBoundingClientRect();
    const pos = {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
    };
    handleDrop(pos);
    selectedCards = null;
    renderBoard();
}

function handleTouchStart(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const pos = {
        x: (e.touches[0].clientX - rect.left) / scale,
        y: (e.touches[0].clientY - rect.top) / scale
    };
    handleClick(pos);
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!selectedCards) return;
    const rect = canvas.getBoundingClientRect();
    selectedCards.pos = {
        x: (e.touches[0].clientX - rect.left) / scale,
        y: (e.touches[0].clientY - rect.top) / scale
    };
    renderBoard();
}

function handleTouchEnd(e) {
    e.preventDefault();
    if (!selectedCards) return;
    const rect = canvas.getBoundingClientRect();
    const pos = {
        x: (e.changedTouches[0].clientX - rect.left) / scale,
        y: (e.changedTouches[0].clientY - rect.top) / scale
    };
    handleDrop(pos);
    selectedCards = null;
    renderBoard();
}

function handleClick(pos) {
    const offsetX = (canvas.width / scale - 800) / 2;
    const offsetY = (canvas.height / scale - 600) / 2;
    if (showSettings && isInBounds(pos, 300 + offsetX, 200 + offsetY, 200, 200)) {
        if (isInBounds(pos, 300 + offsetX, 240 + offsetY, 200, 40)) {
            drawMode = drawMode === 1 ? 3 : 1;
            renderBoard();
            document.getElementById('aria-announcer').textContent = `Draw mode set to ${drawMode}`;
        }
        if (isInBounds(pos, 300 + offsetX, 280 + offsetY, 200, 40)) {
            timed = !timed;
            startTime = Date.now();
            renderBoard();
            document.getElementById('aria-announcer').textContent = `Timed mode ${timed ? 'enabled' : 'disabled'}`;
        }
        if (isInBounds(pos, 300 + offsetX, 320 + offsetY, 200, 40)) {
            hintsEnabled = !hintsEnabled;
            renderBoard();
            document.getElementById('aria-announcer').textContent = `Hints ${hintsEnabled ? 'enabled' : 'disabled'}`;
        }
        if (isInBounds(pos, 300 + offsetX, 360 + offsetY, 200, 40)) {
            showSettings = false;
            renderBoard();
            document.getElementById('aria-announcer').textContent = 'Settings closed';
        }
        return;
    }
    if (showTutorial && isInBounds(pos, 300 + offsetX, 200 + offsetY, 200, 200)) {
        if (isInBounds(pos, 300 + offsetX, 360 + offsetY, 200, 40)) {
            showTutorial = false;
            localStorage.setItem('tutorialSeen', 'true');
            renderBoard();
            document.getElementById('aria-announcer').textContent = 'Tutorial closed';
        }
        return;
    }
    if (isInBounds(pos, 20 + offsetX, 100 + offsetY, cardWidth / scale, cardHeight / scale) && stock.length) {
        for (let i = 0; i < drawMode; i++) {
            if (stock.length) {
                waste.push(stock.pop());
                waste[waste.length - 1].faceUp = true;
                moves.push({type: 'draw', card: waste[waste.length - 1]});
            }
        }
        score -= drawMode;
        renderBoard();
        document.getElementById('aria-announcer').textContent = `Drew ${drawMode} card${drawMode > 1 ? 's' : ''} from stock`;
        return;
    }
    if (isInBounds(pos, 120 + offsetX, 100 + offsetY, cardWidth / scale, cardHeight / scale) && waste.length) {
        selectedCards = {pileType: 'waste', pileIndex: 0, cardIndex: waste.length - 1, cards: [waste[waste.length - 1]], pos};
        dragOffset = {x: pos.x - (120 + offsetX), y: pos.y - (100 + offsetY)};
        renderBoard();
        document.getElementById('aria-announcer').textContent = `Selected ${waste[waste.length - 1].rank} of ${waste[waste.length - 1].suit} from waste`;
        return;
    }
    for (let i = 0; i < 7; i++) {
        const pile = tableau[i];
        for (let j = 0; j < pile.length; j++) {
            if (pile[j].faceUp && isInBounds(pos, 20 + i * 100 + offsetX, 250 + j * 20 + offsetY, cardWidth / scale, cardHeight / scale)) {
                selectedCards = {pileType: 'tableau', pileIndex: i, cardIndex: j, cards: pile.slice(j), pos};
                dragOffset = {x: pos.x - (20 + i * 100 + offsetX), y: pos.y - (250 + j * 20 + offsetY)};
                renderBoard();
                document.getElementById('aria-announcer').textContent = `Selected ${pile[j].rank} of ${pile[j].suit} from tableau ${i + 1}`;
                return;
            }
        }
    }
    if (isInBounds(pos, 650 + offsetX, 20 + offsetY, 100, 40)) {
        undo();
        return;
    }
    if (isInBounds(pos, 650 + offsetX, 70 + offsetY, 100, 40)) {
        hint();
        return;
    }
    if (isInBounds(pos, 650 + offsetX, 120 + offsetY, 100, 40)) {
        newGame();
        document.getElementById('aria-announcer').textContent = 'Started new game';
        return;
    }
    if (isInBounds(pos, 650 + offsetX, 170 + offsetY, 100, 40)) {
        showSettings = true;
        renderBoard();
        document.getElementById('aria-announcer').textContent = 'Opened settings';
        return;
    }
}

function handleDrop(pos) {
    if (!selectedCards) return;
    const offsetX = (canvas.width / scale - 800) / 2;
    const offsetY = (canvas.height / scale - 600) / 2;
    for (let i = 0; i < 4; i++) {
        if (isInBounds(pos, 20 + i * 100 + offsetX, 20 + offsetY, cardWidth / scale, cardHeight / scale)) {
            if (canPlaceOnFoundation(selectedCards.cards[0], foundations[i])) {
                moves.push({type: 'move', from: selectedCards, to: {pileType: 'foundation', pileIndex: i, cardIndex: foundations[i].length, cards: selectedCards.cards}});
                foundations[i].push(...selectedCards.cards);
                if (selectedCards.pileType === 'tableau') {
                    tableau[selectedCards.pileIndex].splice(selectedCards.cardIndex);
                    if (tableau[selectedCards.pileIndex].length && !tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp) {
                        tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp = true;
                        score += 5;
                    }
                } else if (selectedCards.pileType === 'waste') {
                    waste.splice(selectedCards.cardIndex);
                }
                score += 10 * selectedCards.cards.length;
                checkWin();
                renderBoard();
                document.getElementById('aria-announcer').textContent = `Moved ${selectedCards.cards[0].rank} of ${selectedCards.cards[0].suit} to foundation`;
                return;
            }
        }
    }
    for (let i = 0; i < 7; i++) {
        if (isInBounds(pos, 20 + i * 100 + offsetX, 250 + offsetY, cardWidth / scale, cardHeight / scale)) {
            if (canPlaceOnTableau(selectedCards.cards[0], tableau[i])) {
                moves.push({type: 'move', from: selectedCards, to: {pileType: 'tableau', pileIndex: i, cardIndex: tableau[i].length, cards: selectedCards.cards}});
                tableau[i].push(...selectedCards.cards);
                if (selectedCards.pileType === 'tableau') {
                    tableau[selectedCards.pileIndex].splice(selectedCards.cardIndex);
                    if (tableau[selectedCards.pileIndex].length && !tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp) {
                        tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp = true;
                        score += 5;
                    }
                } else if (selectedCards.pileType === 'waste') {
                    waste.splice(selectedCards.cardIndex);
                }
                score += 5 * selectedCards.cards.length;
                renderBoard();
                document.getElementById('aria-announcer').textContent = `Moved ${selectedCards.cards[0].rank} of ${selectedCards.cards[0].suit} to tableau ${i + 1}`;
                return;
            }
        }
    }
    renderBoard();
}

function canPlaceOnFoundation(card, foundation) {
    if (!card.faceUp) return false;
    if (!foundation.length) return card.rank === 'A';
    const topCard = foundation[foundation.length - 1];
    return card.suit === topCard.suit && RANKS.indexOf(card.rank) === RANKS.indexOf(topCard.rank) + 1;
}

function canPlaceOnTableau(card, pile) {
    if (!card.faceUp) return false;
    if (!pile.length) return card.rank === 'K';
    const topCard = pile[pile.length - 1];
    const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
    const isTopRed = topCard.suit === 'hearts' || topCard.suit === 'diamonds';
    return isRed !== isTopRed && RANKS.indexOf(card.rank) === RANKS.indexOf(topCard.rank) - 1;
}

function undo() {
    if (!moves.length) return;
    const move = moves.pop();
    if (move.type === 'draw') {
        for (let i = 0; i < drawMode; i++) {
            if (waste.length) {
                stock.push(waste.pop());
                stock[stock.length - 1].faceUp = false;
            }
        }
        score += drawMode;
    } else if (move.type === 'move') {
        const {from, to} = move;
        if (to.pileType === 'foundation') {
            foundations[to.pileIndex].splice(to.cardIndex);
            score -= 10 * to.cards.length;
        } else if (to.pileType === 'tableau') {
            tableau[to.pileIndex].splice(to.cardIndex);
            score -= 5 * to.cards.length;
        }
        if (from.pileType ===
