const COLORS = {
    GOLD: '#E6D39E',
    BLACK: '#141414',
    RED: '#FF0000',
    DARK_BLACK: '#000000',
    WHITE: '#FFFFFF',
    GRADIENT_START: '#141414',
    GRADIENT_END: '#332B1A'
};
const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const SUIT_SYMBOLS = { hearts: '♥', diamonds: '♦', clubs: '♣', spades: '♠' };
let canvas, ctx;
let cardWidth = 80, cardHeight = 120;
let scale = 1;
let deck = [];
let tableau = Array(7).fill().map(() => []);
let foundations = Array(4).fill().map(() => []);
let stock = [];
let waste = [];
let selectedCards = null;
let dragOffset = {x: 0, y: 0};
let moves = [];
let score = 0;
let drawMode = 1;
let timed = false;
let startTime = 0;
let hintsEnabled = true;
let autoComplete = false;
let wins = 0, losses = 0, streak = 0;
let rank = 'Bronze Chip';
let reducedMotion = false;
let showTutorial = !localStorage.getItem('tutorialSeen');

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

function init() {
    try {
        canvas = document.getElementById('gameCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('Failed to get 2D context');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        canvas.addEventListener('touchend', handleTouchEnd);
        document.addEventListener('keydown', handleKeyDown);
        loadState();
        if (deck.length === 0) newGame();
        requestAnimationFrame(gameLoop);
    } catch (e) {
        console.error('Initialization failed:', e);
        document.getElementById('debug').textContent = `Error: ${e.message}`;
    }
}

function resizeCanvas() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    scale = Math.min(vw / 800, vh / 600);
    canvas.width = vw;
    canvas.height = vh;
    cardWidth = 80 * scale;
    cardHeight = 120 * scale;
    renderBoard();
}

function initDeck() {
    deck = [];
    for (let suit of SUITS) {
        for (let rank of RANKS) {
            deck.push({suit, rank, faceUp: false, id: generateUUID()});
        }
    }
}

function newGame() {
    initDeck();
    shuffle(deck);
    tableau = Array(7).fill().map(() => []);
    for (let i = 0; i < 7; i++) {
        for (let j = 0; j <= i; j++) {
            const card = deck.pop();
            card.faceUp = j === i;
            tableau[i].push(card);
        }
    }
    stock = deck;
    waste = [];
    foundations = Array(4).fill().map(() => []);
    score = 0;
    moves = [];
    startTime = Date.now();
    showTutorial = !localStorage.getItem('tutorialSeen');
    saveState();
    renderBoard();
}

function drawFromStock() {
    if (stock.length === 0) {
        stock = waste.reverse();
        waste = [];
        score -= 2;
    } else {
        const num = Math.min(drawMode, stock.length);
        for (let i = 0; i < num; i++) {
            const card = stock.pop();
            card.faceUp = true;
            waste.push(card);
        }
    }
    saveMove();
    renderBoard();
    document.getElementById('aria-announcer').textContent = 'Drew card from stock';
}

function attemptMove(pos) {
    if (!selectedCards) return;
    for (let i = 0; i < 7; i++) {
        const x = (20 + i * 100) * scale;
        const y = 250 * scale;
        if (isInBounds(pos, x / scale, y / scale, cardWidth / scale, cardHeight / scale)) {
            const card = selectedCards.cards[0];
            const targetPile = tableau[i];
            if (canPlaceOnTableau(card, targetPile)) {
                if (selectedCards.pileType === 'tableau') {
                    tableau[selectedCards.pileIndex].splice(selectedCards.cardIndex);
                } else if (selectedCards.pileType === 'waste') {
                    waste.pop();
                }
                targetPile.push(...selectedCards.cards);
                score += 5;
                if (selectedCards.pileType === 'tableau' && tableau[selectedCards.pileIndex].length > 0) {
                    tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp = true;
                }
                document.getElementById('aria-announcer').textContent = `Moved ${card.rank} of ${card.suit} to tableau ${i + 1}`;
            } else {
                navigator.vibrate?.(50);
                document.getElementById('aria-announcer').textContent = `Invalid move for ${card.rank} of ${card.suit}`;
            }
        }
    }
    for (let i = 0; i < 4; i++) {
        const x = (220 + i * 100) * scale;
        const y = 100 * scale;
        if (isInBounds(pos, x / scale, y / scale, cardWidth / scale, cardHeight / scale)) {
            const card = selectedCards.cards[0];
            const targetPile = foundations[i];
            if (canPlaceOnFoundation(card, targetPile)) {
                if (selectedCards.pileType === 'tableau') {
                    tableau[selectedCards.pileIndex].splice(selectedCards.cardIndex);
                } else if (selectedCards.pileType === 'waste') {
                    waste.pop();
                }
                targetPile.push(card);
                score += 10;
                if (selectedCards.pileType === 'tableau' && tableau[selectedCards.pileIndex].length > 0) {
                    tableau[selectedCards.pileIndex][tableau[selectedCards.pileIndex].length - 1].faceUp = true;
                }
                document.getElementById('aria-announcer').textContent = `Moved ${card.rank} of ${card.suit} to foundation ${i + 1}`;
            } else {
                navigator.vibrate?.(50);
                document.getElementById('aria-announcer').textContent = `Invalid move for ${card.rank} of ${card.suit}`;
            }
        }
    }
    selectedCards = null;
    saveMove();
    if (checkWin()) handleWin();
    renderBoard();
}

function isInBounds(pos, x, y, w, h) {
    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
}

function canPlaceOnTableau(card, pile) {
    if (pile.length === 0) return card.rank === 'K';
    const top = pile[pile.length - 1];
    const rankIndex = RANKS.indexOf(card.rank);
    const topRankIndex = RANKS.indexOf(top.rank);
    const isOppositeColor = (card.suit === 'hearts' || card.suit === 'diamonds') !== (top.suit === 'hearts' || top.suit === 'diamonds');
    return isOppositeColor && rankIndex === topRankIndex - 1;
}

function canPlaceOnFoundation(card, pile) {
    if (pile.length === 0) return card.rank === 'A';
    const top = pile[pile.length - 1];
    const rankIndex = RANKS.indexOf(card.rank);
    const topRankIndex = RANKS.indexOf(top.rank);
    return card.suit === top.suit && rankIndex === topRankIndex + 1;
}

function checkWin() {
    return foundations.every(p => p.length === 13);
}

function handleWin() {
    wins++;
    streak++;
    losses = 0;
    updateRank();
    if (!reducedMotion) animateConfetti();
    document.getElementById('aria-announcer').textContent = 'Congratulations! You won!';
}

function animateConfetti() {
    for (let i = 0; i < 100; i++) {
        setTimeout(() => {
            ctx.fillStyle = COLORS.GOLD;
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 3 * scale, 0, 2 * Math.PI);
            ctx.fill();
        }, i * 20);
    }
}

function saveMove() {
    moves.push(JSON.stringify({tableau, foundations, stock, waste, score}));
    if (moves.length > 20) moves.shift();
}

function undo() {
    if (moves.length > 0) {
        const prev = JSON.parse(moves.pop());
        tableau = prev.tableau;
        foundations = prev.foundations;
        stock = prev.stock;
        waste = prev.waste;
        score = prev.score;
        renderBoard();
        document.getElementById('aria-announcer').textContent = 'Undo performed';
    }
}

function hint() {
    if (hintsEnabled) {
        document.getElementById('aria-announcer').textContent = 'Hint: Check available moves';
    }
}

function updateRank() {
    const winRate = wins / (wins + losses) * 100;
    if (winRate > 90) rank = 'Gold Baron';
    else if (winRate > 50) rank = 'Silver Dealer';
    else rank = 'Bronze Chip';
}

function saveState() {
    localStorage.setItem('casinoSocietySolitaire', JSON.stringify({
        tableau, foundations, stock, waste, score, wins, losses, streak, rank, drawMode, timed, reducedMotion
    }));
}

function loadState() {
    const saved = localStorage.getItem('casinoSocietySolitaire');
    if (saved) {
        const data = JSON.parse(saved);
        tableau = data.tableau || tableau;
        foundations = data.foundations || foundations;
        stock = data.stock || stock;
        waste = data.waste || waste;
        score = data.score || 0;
        wins = data.wins || 0;
        losses = data.losses || 0;
        streak = data.streak || 0;
        rank = data.rank || 'Bronze Chip';
        drawMode = data.drawMode || 1;
        timed = data.timed || false;
        reducedMotion = data.reducedMotion || false;
    }
}

function renderBoard() {
    try {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, COLORS.GRADIENT_START);
        gradient.addColorStop(1, COLORS.GRADIENT_END);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = `${40 * scale}px 'Playfair Display', serif`;
        ctx.fillStyle = COLORS.GOLD;
        ctx.fillText('CS', 20 * scale, 50 * scale);

        ctx.font = `${16 * scale}px Arial, sans-serif`;
        ctx.fillText('No Crying in the Casino', 20 * scale, 70 * scale);

        drawPile(stock, 20 * scale, 100 * scale, false);
        drawPile(waste, 120 * scale, 100 * scale, true);
        for (let i = 0; i < 4; i++) {
            drawFoundation(i, (220 + i * 100) * scale, 100 * scale);
        }
        for (let i = 0; i < 7; i++) {
            drawTableau(i, (20 + i * 100) * scale, 250 * scale);
        }

        ctx.fillText(`Score: ${score} | Rank: ${rank}`, 20 * scale, 80 * scale);
        drawButton('Undo', 600 * scale, 20 * scale, 100 * scale, 40 * scale);
        drawButton('Hint', 700 * scale, 20 * scale, 100 * scale, 40 * scale);
        drawButton('New Game', 600 * scale, 70 * scale, 100 * scale, 40 * scale);
        drawButton('Settings', 700 * scale, 70 * scale, 100 * scale, 40 * scale);
        drawButton('Home', 500 * scale, 20 * scale, 100 * scale, 40 * scale);

        if (selectedCards) {
            const card = selectedCards.cards[0];
            drawCard(card, pos.x - dragOffset.x, pos.y - dragOffset.y, true);
        }

        if (showTutorial) {
            ctx.fillStyle = COLORS.BLACK + 'AA';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = COLORS.GOLD;
            ctx.font = `${20 * scale}px Arial, sans-serif`;
            ctx.fillText('Welcome to Casino Society Solitaire!', 100 * scale, 200 * scale);
            ctx.fillText('Click stock (top-left) to draw cards.', 100 * scale, 240 * scale);
            ctx.fillText('Click face-up cards to select, then click tableau or foundation to move.', 100 * scale, 260 * scale);
            ctx.fillText('Click anywhere to continue.', 100 * scale, 300 * scale);
        }
    } catch (e) {
        console.error('Render failed:', e);
        document.getElementById('debug').textContent = `Error: ${e.message}`;
    }
}

function drawCard(card, x, y, faceUp) {
    ctx.fillStyle = COLORS.WHITE;
    ctx.fillRect(x, y, cardWidth, cardHeight);
    ctx.strokeStyle = COLORS.BLACK;
    ctx.lineWidth = 2 * scale;
    ctx.strokeRect(x, y, cardWidth, cardHeight);
    ctx.shadowColor = COLORS.GOLD + '33';
    ctx.shadowBlur = selectedCards && selectedCards.cards.includes(card) ? 10 : 0;

    if (faceUp) {
        const color = (card.suit === 'hearts' || card.suit === 'diamonds') ? COLORS.RED : COLORS.DARK_BLACK;
        ctx.fillStyle = color;
        ctx.font = `${20 * scale}px Arial, sans-serif`;
        ctx.fillText(card.rank + SUIT_SYMBOLS[card.suit], x + 10 * scale, y + 25 * scale);
        ctx.fillStyle = COLORS.GOLD + '33';
        ctx.fillText('CS', x + cardWidth / 2, y + cardHeight / 2);
    } else {
        ctx.fillStyle = COLORS.GOLD;
        ctx.beginPath();
        ctx.arc(x + cardWidth / 2, y + cardHeight / 2, 20 * scale, 0, 2 * Math.PI);
        ctx.fill();
    }
    ctx.shadowBlur = 0;
}

function drawPile(pile, x, y, showTopOnly) {
    if (pile.length === 0) {
        ctx.strokeStyle = COLORS.GOLD;
        ctx.strokeRect(x, y, cardWidth, cardHeight);
        return;
    }
    if (showTopOnly) {
        drawCard(pile[pile.length - 1], x, y, true);
    } else {
        drawCard({faceUp: false}, x, y, false);
    }
}

function drawFoundation(index, x, y) {
    if (foundations[index].length === 0) {
        ctx.strokeStyle = COLORS.GOLD;
        ctx.strokeRect(x, y, cardWidth, cardHeight);
    } else {
        drawCard(foundations[index][foundations[index].length - 1], x, y, true);
    }
}

function drawTableau(index, x, y) {
    const pile = tableau[index];
    for (let i = 0; i < pile.length; i++) {
        drawCard(pile[i], x, y + i * 20 * scale, pile[i].faceUp);
    }
}

function drawButton(text, x, y, w, h) {
    ctx.fillStyle = COLORS.GOLD;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = COLORS.BLACK;
    ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = COLORS.BLACK;
    ctx.font = `${16 * scale}px Arial, sans-serif`;
    ctx.fillText(text, x + 10 * scale, y + 25 * scale);
}

function handleMouseDown(e) {
    const pos = getMousePos(e);
    handleClick(pos);
}

function handleTouchStart(e) {
    e.preventDefault();
    const pos = getTouchPos(e);
    handleClick(pos);
    if (isInBounds(pos, 20, 100, cardWidth / scale, cardHeight / scale)) {
        navigator.vibrate?.(50);
    }
}

function handleMouseMove(e) {
    if (selectedCards) {
        const pos = getMousePos(e);
        renderBoard(); // Redraw board
        drawCard(selectedCards.cards[0], pos.x - dragOffset.x, pos.y - dragOffset.y, true); // Draw dragging card
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    if (selectedCards) {
        const pos = getTouchPos(e);
        renderBoard();
        drawCard(selectedCards.cards[0], pos.x - dragOffset.x, pos.y - dragOffset.y, true);
    }
}

function handleMouseUp(e) {
    const pos = getMousePos(e);
    attemptMove(pos);
}

function handleTouchEnd(e) {
    e.preventDefault();
    const pos = getTouchPos(e);
    attemptMove(pos);
}

function handleKeyDown(e) {
    if (e.key === 'z' && e.ctrlKey) {
        undo();
        return;
    }
    if (e.key === 'h') {
        hint();
        return;
    }
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {x: (e.clientX - rect.left) / scale, y: (e.clientY - rect.top) / scale};
}

function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {x: (e.touches[0].clientX - rect.left) / scale, y: (e.touches[0].clientY - rect.top) / scale};
}

function handleClick(pos) {
    if (showTutorial) {
        showTutorial = false;
        localStorage.setItem('tutorialSeen', 'true');
        renderBoard();
        return;
    }
    if (isInBounds(pos, 20, 100, cardWidth / scale, cardHeight / scale)) {
        drawFromStock();
        return;
    }
    if (waste.length > 0 && isInBounds(pos, 120, 100, cardWidth / scale, cardHeight / scale)) {
        selectedCards = {pileType: 'waste', pileIndex: 0, cardIndex: waste.length - 1, cards: [waste[waste.length - 1]]};
        dragOffset.x = pos.x - 120;
        dragOffset.y = pos.y - 100;
        renderBoard();
        document.getElementById('aria-announcer').textContent = `Selected ${waste[waste.length - 1].rank} of ${waste[waste.length - 1].suit} from waste`;
        return;
    }
    for (let i = 0; i < 7; i++) {
        const pile = tableau[i];
        for (let j = 0; j < pile.length; j++) {
            if (pile[j].faceUp && isInBounds(pos, 20 + i * 100, 250 + j * 20, cardWidth / scale, cardHeight / scale)) {
                selectedCards = {pileType: 'tableau', pileIndex: i, cardIndex: j, cards: pile.slice(j)};
                dragOffset.x = pos.x - (20 + i * 100);
                dragOffset.y = pos.y - (250 + j * 20);
                renderBoard();
                document.getElementById('aria-announcer').textContent = `Selected ${pile[j].rank} of ${pile[j].suit} from tableau ${i + 1}`;
                return;
            }
        }
    }
    if (isInBounds(pos, 600, 20, 100, 40)) {
        undo();
        return;
    }
    if (isInBounds(pos, 700, 20, 100, 40)) {
        hint();
        return;
    }
    if (isInBounds(pos, 600, 70, 100, 40)) {
        newGame();
        document.getElementById('aria-announcer').textContent = 'Started new game';
        return;
    }
    if (isInBounds(pos, 700, 70, 100, 40)) {
        ctx.fillStyle = COLORS.BLACK;
        ctx.fillRect(200 * scale, 150 * scale, 400 * scale, 300 * scale);
        ctx.fillStyle = COLORS.GOLD;
        ctx.font = `${20 * scale}px Arial, sans-serif`;
        ctx.fillText('Settings', 250 * scale, 180 * scale);
        ctx.fillText('Draw: ' + (drawMode === 1 ? '1 Card' : '3 Cards'), 250 * scale, 220 * scale);
        ctx.fillText('Click to toggle draw mode', 250 * scale, 260 * scale);
        document.getElementById('aria-announcer').textContent = 'Opened settings';
        if (isInBounds(pos, 250, 220, 150, 40)) {
            drawMode = drawMode === 1 ? 3 : 1;
            saveState();
            renderBoard();
        }
        return;
    }
    if (isInBounds(pos, 500, 20, 100, 40)) {
        window.location.href = '../index.html';
        return;
    }
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
}

init();
